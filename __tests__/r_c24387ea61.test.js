// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=r_010b511b7b
ROOST_METHOD_SIG_HASH=r_c24387ea61


*/

// ********RoostGPT********
const { r } = require('../src/public/javascripts/library/angular-resource.min.js');

describe('r function', () => {
  test('should handle empty input', () => {
    const result = r({}, {});
    expect(result).toEqual({});
  });

  test('should process simple key-value pairs', () => {
    const input = { key1: 'value1', key2: 'value2' };
    const result = r({}, input);
    expect(result).toEqual(input);
  });

  test('should handle function values', () => {
    const input = { key: () => 'functionValue' };
    const result = r({}, input);
    expect(result).toEqual({ key: 'functionValue' });
  });

  test('should process @ prefixed values', () => {
    const h = { prop: 'value' };
    const input = { key: '@prop' };
    const result = r(h, input);
    expect(result).toEqual({ key: 'value' });
  });

  test('should handle nested @ prefixed values', () => {
    const h = { nested: { prop: 'nestedValue' } };
    const input = { key: '@nested.prop' };
    const result = r(h, input);
    expect(result).toEqual({ key: 'nestedValue' });
  });

  test('should throw error for invalid @ prefixed values', () => {
    const h = {};
    const input = { key: '@invalid.prop' };
    expect(() => r(h, input)).toThrow();
  });

  test('should handle undefined values', () => {
    const input = { key: undefined };
    const result = r({}, input);
    expect(result).toEqual({ key: undefined });
  });

  test('should handle null values', () => {
    const input = { key: null };
    const result = r({}, input);
    expect(result).toEqual({ key: null });
  });

  test('should handle complex nested objects', () => {
    const h = { a: { b: { c: 'deep' } } };
    const input = { key1: '@a.b.c', key2: 'static' };
    const result = r(h, input);
    expect(result).toEqual({ key1: 'deep', key2: 'static' });
  });

  test('should handle array values', () => {
    const input = { key: [1, 2, 3] };
    const result = r({}, input);
    expect(result).toEqual(input);
  });

  test('should handle mixed input types', () => {
    const h = { prop: 'value' };
    const input = {
      key1: '@prop',
      key2: () => 'function',
      key3: [1, 2, 3],
      key4: { nested: 'object' }
    };
    const result = r(h, input);
    expect(result).toEqual({
      key1: 'value',
      key2: 'function',
      key3: [1, 2, 3],
      key4: { nested: 'object' }
    });
  });
});
