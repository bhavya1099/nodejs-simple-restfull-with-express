// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Ja_c7a9520d12
ROOST_METHOD_SIG_HASH=Ja_5a217054db


*/

// ********RoostGPT********
const { Ja } = require('../src/public/javascripts/library/angular.min.js');

describe('Ja function', () => {
  test('should return string with type and hashKey for objects', () => {
    const obj = { $hashKey: 'abc123' };
    expect(Ja(obj)).toBe('object:abc123');
  });

  test('should return string with type and hashKey for functions', () => {
    const func = function() {};
    func.$hashKey = 'xyz789';
    expect(Ja(func)).toBe('function:xyz789');
  });

  test('should generate hashKey for objects without $hashKey', () => {
    const obj = {};
    const result = Ja(obj);
    expect(result).toMatch(/^object:\w+$/);
  });

  test('should generate hashKey for functions without $hashKey', () => {
    const func = function() {};
    const result = Ja(func);
    expect(result).toMatch(/^function:\w+$/);
  });

  test('should return string with type and value for primitives', () => {
    expect(Ja(42)).toBe('number:42');
    expect(Ja('test')).toBe('string:test');
    expect(Ja(true)).toBe('boolean:true');
  });

  test('should handle null input', () => {
    expect(Ja(null)).toBe('object:null');
  });

  test('should handle undefined input', () => {
    expect(Ja(undefined)).toBe('undefined:undefined');
  });

  test('should use provided hashKey function if given', () => {
    const obj = {};
    const customHashKey = jest.fn().mockReturnValue('custom123');
    expect(Ja(obj, customHashKey)).toBe('object:custom123');
    expect(customHashKey).toHaveBeenCalledWith(obj);
  });

  test('should use default hashKey function if not provided', () => {
    const obj = {};
    const result = Ja(obj);
    expect(result).toMatch(/^object:\w+$/);
  });

  test('should return same hashKey for same object on multiple calls', () => {
    const obj = {};
    const result1 = Ja(obj);
    const result2 = Ja(obj);
    expect(result1).toBe(result2);
  });

  test('should return different hashKeys for different objects', () => {
    const obj1 = {};
    const obj2 = {};
    const result1 = Ja(obj1);
    const result2 = Ja(obj2);
    expect(result1).not.toBe(result2);
  });
});
