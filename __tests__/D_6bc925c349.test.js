// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=D_e05ff9dbf4
ROOST_METHOD_SIG_HASH=D_6bc925c349


*/

// ********RoostGPT********
const { D } = require('../../../src/public/javascripts/library/angular-resource.min.js');

describe('D function', () => {
  test('should remove properties from g object', () => {
    const p = { a: 1, b: 2 };
    const g = { c: 3, d: 4 };
    const result = D(p, g);
    expect(result).toEqual({ a: 1, b: 2 });
    expect(g).toEqual({});
  });

  test('should copy properties from p to g', () => {
    const p = { a: 1, b: 2 };
    const g = {};
    const result = D(p, g);
    expect(result).toEqual({ a: 1, b: 2 });
    expect(g).toEqual({ a: 1, b: 2 });
  });

  test('should not copy properties starting with $$', () => {
    const p = { a: 1, $$b: 2, $c: 3 };
    const g = {};
    const result = D(p, g);
    expect(result).toEqual({ a: 1, $c: 3 });
    expect(g).toEqual({ a: 1, $c: 3 });
  });

  test('should handle empty p object', () => {
    const p = {};
    const g = { a: 1 };
    const result = D(p, g);
    expect(result).toEqual({});
    expect(g).toEqual({});
  });

  test('should handle undefined g parameter', () => {
    const p = { a: 1, b: 2 };
    const result = D(p);
    expect(result).toEqual({ a: 1, b: 2 });
  });

  test('should handle non-object p parameter', () => {
    const p = 'string';
    const g = {};
    const result = D(p, g);
    expect(result).toEqual({});
    expect(g).toEqual({});
  });

  test('should handle non-object g parameter', () => {
    const p = { a: 1, b: 2 };
    const g = 'string';
    const result = D(p, g);
    expect(result).toEqual({ a: 1, b: 2 });
  });

  test('should handle null p parameter', () => {
    const p = null;
    const g = { a: 1 };
    const result = D(p, g);
    expect(result).toEqual({});
    expect(g).toEqual({});
  });

  test('should handle null g parameter', () => {
    const p = { a: 1, b: 2 };
    const result = D(p, null);
    expect(result).toEqual({ a: 1, b: 2 });
  });

  test('should handle complex nested objects', () => {
    const p = { a: { b: { c: 1 } }, d: [1, 2, 3] };
    const g = { e: { f: 2 } };
    const result = D(p, g);
    expect(result).toEqual({ a: { b: { c: 1 } }, d: [1, 2, 3] });
    expect(g).toEqual({ a: { b: { c: 1 } }, d: [1, 2, 3] });
  });
});
