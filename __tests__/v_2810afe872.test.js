// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=v_4984a7f005
ROOST_METHOD_SIG_HASH=v_2810afe872


*/

// ********RoostGPT********
const { v } = require('../../../src/public/javascripts/library/angular.min.js');

describe('v function', () => {
  let mockA, mockC, mockB, mockHa;

  beforeEach(() => {
    mockA = [];
    mockC = {};
    mockB = jest.fn().mockReturnValue(true);
    mockHa = jest.fn();

    global.b = mockB;
    global.ha = mockHa;
  });

  test('should push an object to the array when d is truthy', () => {
    v(mockA, mockC);
    expect(mockA).toHaveLength(1);
    expect(mockA[0]).toHaveProperty('priority', 0);
    expect(mockA[0]).toHaveProperty('compile');
  });

  test('should not push an object to the array when d is falsy', () => {
    mockB.mockReturnValueOnce(false);
    v(mockA, mockC);
    expect(mockA).toHaveLength(0);
  });

  test('compile function should return a function', () => {
    v(mockA, mockC);
    const compileFn = mockA[0].compile;
    const result = compileFn({ parent: () => ({ length: 1 }) });
    expect(typeof result).toBe('function');
  });

  test('compile function should call ha when parent length is 0', () => {
    v(mockA, mockC);
    const compileFn = mockA[0].compile;
    const mockParent = { parent: () => ({ length: 0 }) };
    compileFn(mockParent);
    expect(mockHa).toHaveBeenCalledWith(mockParent.parent(), 'ng-binding');
  });

  test('returned function should set up $watch', () => {
    v(mockA, mockC);
    const compileFn = mockA[0].compile;
    const linkFn = compileFn({ parent: () => ({ length: 1 }) });

    const mockScope = { $watch: jest.fn() };
    const mockElement = [{ nodeValue: '' }];
    const mockParent = {
      data: jest.fn().mockReturnValue([]),
      parent: () => ({ length: 1 }),
    };

    linkFn(mockScope, { parent: () => mockParent, 0: mockElement[0] });

    expect(mockScope.$watch).toHaveBeenCalled();
    expect(mockParent.data).toHaveBeenCalledWith('$binding');
  });

  test('$watch callback should update nodeValue', () => {
    v(mockA, mockC);
    const compileFn = mockA[0].compile;
    const linkFn = compileFn({ parent: () => ({ length: 1 }) });

    const mockScope = { 
      $watch: jest.fn().mockImplementation((exp, callback) => callback('new value'))
    };
    const mockElement = [{ nodeValue: 'old value' }];
    const mockParent = {
      data: jest.fn().mockReturnValue([]),
      parent: () => ({ length: 1 }),
    };

    linkFn(mockScope, { parent: () => mockParent, 0: mockElement[0] });

    expect(mockElement[0].nodeValue).toBe('new value');
  });
});
