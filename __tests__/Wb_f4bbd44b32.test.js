// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Wb_a019853793
ROOST_METHOD_SIG_HASH=Wb_f4bbd44b32


*/

// ********RoostGPT********
const Wb = require('../src/public/javascripts/library/angular.min.js').Wb;

describe('Wb function', () => {
  test('should return a function', () => {
    const result = Wb(() => {});
    expect(typeof result).toBe('function');
  });

  test('should call the provided function with swapped arguments', () => {
    const mockFn = jest.fn();
    const wrappedFn = Wb(mockFn);
    
    wrappedFn('arg1', 'arg2');
    
    expect(mockFn).toHaveBeenCalledWith('arg2', 'arg1');
  });

  test('should handle undefined arguments', () => {
    const mockFn = jest.fn();
    const wrappedFn = Wb(mockFn);
    
    wrappedFn(undefined, undefined);
    
    expect(mockFn).toHaveBeenCalledWith(undefined, undefined);
  });

  test('should work with different argument types', () => {
    const mockFn = jest.fn();
    const wrappedFn = Wb(mockFn);
    
    wrappedFn(42, 'string');
    
    expect(mockFn).toHaveBeenCalledWith('string', 42);
  });

  test('should preserve the return value of the original function', () => {
    const originalFn = jest.fn(() => 'result');
    const wrappedFn = Wb(originalFn);
    
    const result = wrappedFn('arg1', 'arg2');
    
    expect(result).toBe('result');
  });

  test('should handle functions with more than two arguments', () => {
    const mockFn = jest.fn();
    const wrappedFn = Wb(mockFn);
    
    wrappedFn('arg1', 'arg2', 'arg3');
    
    expect(mockFn).toHaveBeenCalledWith('arg2', 'arg1');
    expect(mockFn).not.toHaveBeenCalledWith('arg2', 'arg1', 'arg3');
  });

  test('should work with arrow functions', () => {
    const mockFn = jest.fn((x, y) => x + y);
    const wrappedFn = Wb(mockFn);
    
    const result = wrappedFn(2, 3);
    
    expect(result).toBe(5);
    expect(mockFn).toHaveBeenCalledWith(3, 2);
  });

  test('should maintain the context of the original function', () => {
    const obj = {
      value: 42,
      method: function(x, y) {
        return this.value + x + y;
      }
    };
    
    const wrappedMethod = Wb(obj.method.bind(obj));
    
    const result = wrappedMethod(10, 5);
    
    expect(result).toBe(57);
  });
});
