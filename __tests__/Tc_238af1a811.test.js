// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Tc_0201ac1070
ROOST_METHOD_SIG_HASH=Tc_238af1a811


*/

// ********RoostGPT********
const { Tc } = require('../../../src/public/javascripts/library/angular.min.js');

describe('Tc function', () => {
  test('should iterate over object properties and call the provided function', () => {
    const obj = { a: 1, b: 2, c: 3 };
    const mockFn = jest.fn();
    const context = {};

    const result = Tc(obj, mockFn, context);

    expect(mockFn).toHaveBeenCalledTimes(3);
    expect(mockFn).toHaveBeenCalledWith(1, 'a');
    expect(mockFn).toHaveBeenCalledWith(2, 'b');
    expect(mockFn).toHaveBeenCalledWith(3, 'c');
    expect(mockFn.mock.instances[0]).toBe(context);
    expect(result).toEqual(['a', 'b', 'c']);
  });

  test('should handle empty objects', () => {
    const obj = {};
    const mockFn = jest.fn();
    const context = {};

    const result = Tc(obj, mockFn, context);

    expect(mockFn).not.toHaveBeenCalled();
    expect(result).toEqual([]);
  });

  test('should handle arrays', () => {
    const arr = [1, 2, 3];
    const mockFn = jest.fn();
    const context = {};

    const result = Tc(arr, mockFn, context);

    expect(mockFn).toHaveBeenCalledTimes(3);
    expect(mockFn).toHaveBeenCalledWith(1, '0');
    expect(mockFn).toHaveBeenCalledWith(2, '1');
    expect(mockFn).toHaveBeenCalledWith(3, '2');
    expect(result).toEqual(['0', '1', '2']);
  });

  test('should handle null and undefined', () => {
    const mockFn = jest.fn();
    const context = {};

    expect(() => Tc(null, mockFn, context)).not.toThrow();
    expect(() => Tc(undefined, mockFn, context)).not.toThrow();
    expect(mockFn).not.toHaveBeenCalled();
  });

  test('should handle non-object types', () => {
    const mockFn = jest.fn();
    const context = {};

    const result1 = Tc(42, mockFn, context);
    const result2 = Tc('string', mockFn, context);
    const result3 = Tc(true, mockFn, context);

    expect(mockFn).not.toHaveBeenCalled();
    expect(result1).toEqual([]);
    expect(result2).toEqual([]);
    expect(result3).toEqual([]);
  });

  test('should use the provided context', () => {
    const obj = { a: 1 };
    const context = { multiplier: 2 };
    const mockFn = jest.fn(function(value) {
      return value * this.multiplier;
    });

    Tc(obj, mockFn, context);

    expect(mockFn).toHaveBeenCalledWith(1, 'a');
    expect(mockFn.mock.results[0].value).toBe(2);
  });

  test('should return the result of Vb function', () => {
    const obj = { a: 1, b: 2 };
    const mockFn = jest.fn();
    const mockVb = jest.fn(() => ['x', 'y']);
    global.Vb = mockVb;

    const result = Tc(obj, mockFn, {});

    expect(mockVb).toHaveBeenCalledWith(obj);
    expect(result).toEqual(['x', 'y']);
    delete global.Vb;
  });
});
