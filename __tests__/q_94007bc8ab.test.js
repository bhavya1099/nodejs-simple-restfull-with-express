// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=q_be0e7a29d7
ROOST_METHOD_SIG_HASH=q_94007bc8ab


*/

// ********RoostGPT********
const { q } = require('../src/public/javascripts/library/angular.min.js');

describe('q function', () => {
  test('iterates over object properties', () => {
    const obj = { a: 1, b: 2, c: 3 };
    const mockCallback = jest.fn();
    q(obj, mockCallback);
    expect(mockCallback).toHaveBeenCalledTimes(3);
    expect(mockCallback).toHaveBeenCalledWith(1, 'a');
    expect(mockCallback).toHaveBeenCalledWith(2, 'b');
    expect(mockCallback).toHaveBeenCalledWith(3, 'c');
  });

  test('skips prototype, length, and name properties', () => {
    const obj = { prototype: 'skip', length: 'skip', name: 'skip', valid: 'call' };
    const mockCallback = jest.fn();
    q(obj, mockCallback);
    expect(mockCallback).toHaveBeenCalledTimes(1);
    expect(mockCallback).toHaveBeenCalledWith('call', 'valid');
  });

  test('uses forEach if available', () => {
    const arr = [1, 2, 3];
    arr.forEach = jest.fn();
    const mockCallback = jest.fn();
    q(arr, mockCallback);
    expect(arr.forEach).toHaveBeenCalledWith(mockCallback, undefined);
  });

  test('iterates over array-like objects', () => {
    const arrLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
    const mockCallback = jest.fn();
    q(arrLike, mockCallback);
    expect(mockCallback).toHaveBeenCalledTimes(3);
    expect(mockCallback).toHaveBeenCalledWith('a', 0);
    expect(mockCallback).toHaveBeenCalledWith('b', 1);
    expect(mockCallback).toHaveBeenCalledWith('c', 2);
  });

  test('handles null and undefined inputs', () => {
    const mockCallback = jest.fn();
    expect(() => q(null, mockCallback)).not.toThrow();
    expect(() => q(undefined, mockCallback)).not.toThrow();
    expect(mockCallback).not.toHaveBeenCalled();
  });

  test('returns the input object', () => {
    const obj = { a: 1 };
    const result = q(obj, () => {});
    expect(result).toBe(obj);
  });

  test('uses provided context for callback', () => {
    const obj = { a: 1 };
    const context = { test: true };
    const mockCallback = jest.fn(function() {
      expect(this).toBe(context);
    });
    q(obj, mockCallback, context);
    expect(mockCallback).toHaveBeenCalled();
  });

  test('handles empty objects', () => {
    const obj = {};
    const mockCallback = jest.fn();
    q(obj, mockCallback);
    expect(mockCallback).not.toHaveBeenCalled();
  });

  test('handles empty arrays', () => {
    const arr = [];
    const mockCallback = jest.fn();
    q(arr, mockCallback);
    expect(mockCallback).not.toHaveBeenCalled();
  });

  test('iterates over string characters', () => {
    const str = 'abc';
    const mockCallback = jest.fn();
    q(str, mockCallback);
    expect(mockCallback).toHaveBeenCalledTimes(3);
    expect(mockCallback).toHaveBeenCalledWith('a', '0');
    expect(mockCallback).toHaveBeenCalledWith('b', '1');
    expect(mockCallback).toHaveBeenCalledWith('c', '2');
  });
});
