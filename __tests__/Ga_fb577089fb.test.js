// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Ga_4a09f20306
ROOST_METHOD_SIG_HASH=Ga_fb577089fb


*/

// ********RoostGPT********
const { Ga } = require('../src/public/javascripts/library/angular.min.js');

describe('Ga function', () => {
  test('should throw an error when first argument is Ea or has $evalAsync and $watch', () => {
    const mockEa = { $evalAsync: jest.fn(), $watch: jest.fn() };
    expect(() => Ga(mockEa)).toThrow();
  });

  test('should return the input when second argument is falsy', () => {
    const input = { key: 'value' };
    expect(Ga(input)).toEqual(input);
  });

  test('should throw an error when first and second arguments are the same', () => {
    const obj = {};
    expect(() => Ga(obj, obj)).toThrow();
  });

  test('should handle array input', () => {
    const input = [1, 2, 3];
    const result = Ga(input, []);
    expect(result).toEqual(input);
    expect(result).not.toBe(input);
  });

  test('should handle object input', () => {
    const input = { a: 1, b: 2 };
    const result = Ga(input, {});
    expect(result).toEqual(input);
    expect(result).not.toBe(input);
  });

  test('should handle nested objects and arrays', () => {
    const input = { a: [1, 2], b: { c: 3 } };
    const result = Ga(input, {});
    expect(result).toEqual(input);
    expect(result).not.toBe(input);
    expect(result.a).not.toBe(input.a);
    expect(result.b).not.toBe(input.b);
  });

  test('should handle Date objects', () => {
    const input = new Date();
    const result = Ga(input);
    expect(result).toEqual(input);
    expect(result).not.toBe(input);
  });

  test('should handle RegExp objects', () => {
    const input = /test/g;
    const result = Ga(input);
    expect(result).toEqual(input);
    expect(result).not.toBe(input);
  });

  test('should handle circular references', () => {
    const input = { a: 1 };
    input.self = input;
    const result = Ga(input, {});
    expect(result.a).toBe(1);
    expect(result.self).toBe(result);
  });

  test('should preserve object prototype', () => {
    function CustomObj() { this.prop = 1; }
    CustomObj.prototype.method = function() {};
    const input = new CustomObj();
    const result = Ga(input, {});
    expect(result instanceof CustomObj).toBe(true);
    expect(result.prop).toBe(1);
    expect(typeof result.method).toBe('function');
  });
});
