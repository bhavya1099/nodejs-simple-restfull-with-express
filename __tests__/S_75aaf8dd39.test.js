// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=S_01feb0ce13
ROOST_METHOD_SIG_HASH=S_75aaf8dd39


*/

// ********RoostGPT********
const { S } = require('../src/public/javascripts/library/angular.min.js');

describe('S function', () => {
  let mockB, mockLa, mockIa, mockGa, mockF, mockT;

  beforeEach(() => {
    mockB = jest.fn();
    mockLa = jest.fn();
    mockIa = jest.fn();
    mockGa = jest.fn();
    mockF = { test: jest.fn() };
    mockT = jest.fn();

    global.b = mockB;
    global.La = mockLa;
    global.ia = mockIa;
    global.ga = mockGa;
    global.f = mockF;
    global.T = mockT;
  });

  test('should throw error for multiple select', () => {
    mockB.mockReturnValue(true);
    mockLa.mockReturnValue('SELECT');

    expect(() => S({}, [], {}, 'multiple')).toThrow();
    expect(mockIa).toHaveBeenCalledWith('selmulti', expect.any(Function));
  });

  test('should push compile function to array for valid input', () => {
    mockB.mockReturnValue(true);
    mockLa.mockReturnValue('INPUT');

    const mockArray = [];
    S({}, mockArray, {}, 'change');

    expect(mockArray.length).toBe(1);
    expect(mockArray[0].priority).toBe(100);
    expect(typeof mockArray[0].compile).toBe('function');
  });

  test('compile function should return object with pre function', () => {
    mockB.mockReturnValue(true);
    mockLa.mockReturnValue('INPUT');

    const mockArray = [];
    S({}, mockArray, {}, 'change');

    const compiledObj = mockArray[0].compile();
    expect(typeof compiledObj.pre).toBe('function');
  });

  test('pre function should set up observers and watchers', () => {
    mockB.mockReturnValue(() => 'mockValue');
    mockLa.mockReturnValue('INPUT');
    mockF.test.mockReturnValue(false);

    const mockArray = [];
    S({}, mockArray, {}, 'change');

    const compiledObj = mockArray[0].compile();
    const mockScope = { $watch: jest.fn() };
    const mockElement = {};
    const mockAttrs = { $observers: {}, change: 'oldValue', $set: jest.fn() };

    compiledObj.pre(mockScope, mockElement, mockAttrs);

    expect(mockAttrs.change).toBe('mockValue');
    expect(mockAttrs.$observers.change.$inter).toBe(true);
    expect(mockScope.$watch).toHaveBeenCalled();
  });

  test('should throw error for DOM events', () => {
    mockB.mockReturnValue(true);
    mockLa.mockReturnValue('INPUT');
    mockF.test.mockReturnValue(true);

    const mockArray = [];
    S({}, mockArray, {}, 'click');

    const compiledObj = mockArray[0].compile();
    
    expect(() => compiledObj.pre({}, {}, { click: 'value' })).toThrow();
    expect(mockIa).toHaveBeenCalledWith('nodomevents');
  });

  test('should update class when attribute is class', () => {
    mockB.mockReturnValue(() => 'mockValue');
    mockLa.mockReturnValue('INPUT');
    mockF.test.mockReturnValue(false);

    const mockArray = [];
    S({}, mockArray, {}, 'class');

    const compiledObj = mockArray[0].compile();
    const mockScope = { $watch: jest.fn() };
    const mockElement = {};
    const mockAttrs = { 
      $observers: {}, 
      class: 'oldValue', 
      $set: jest.fn(),
      $updateClass: jest.fn()
    };

    compiledObj.pre(mockScope, mockElement, mockAttrs);

    const watchCallback = mockScope.$watch.mock.calls[0][1];
    watchCallback('newValue', 'oldValue');

    expect(mockAttrs.$updateClass).toHaveBeenCalledWith('newValue', 'oldValue');
  });

  test('should set attribute for non-class attributes', () => {
    mockB.mockReturnValue(() => 'mockValue');
    mockLa.mockReturnValue('INPUT');
    mockF.test.mockReturnValue(false);

    const mockArray = [];
    S({}, mockArray, {}, 'data');

    const compiledObj = mockArray[0].compile();
    const mockScope = { $watch: jest.fn() };
    const mockElement = {};
    const mockAttrs = { 
      $observers: {}, 
      data: 'oldValue', 
      $set: jest.fn(),
      $updateClass: jest.fn()
    };

    compiledObj.pre(mockScope, mockElement, mockAttrs);

    const watchCallback = mockScope.$watch.mock.calls[0][1];
    watchCallback('newValue', 'oldValue');

    expect(mockAttrs.$set).toHaveBeenCalledWith('data', 'newValue');
  });
});
