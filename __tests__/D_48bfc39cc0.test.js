// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=D_4f19b6146d
ROOST_METHOD_SIG_HASH=D_48bfc39cc0


*/

// ********RoostGPT********
const { D } = require('../../../src/public/javascripts/library/angular.min.js');

describe('D function', () => {
  test('should return negative when a has lower priority', () => {
    const a = { priority: 1, name: 'a', index: 0 };
    const b = { priority: 2, name: 'b', index: 0 };
    expect(D(a, b)).toBeLessThan(0);
  });

  test('should return positive when a has higher priority', () => {
    const a = { priority: 2, name: 'a', index: 0 };
    const b = { priority: 1, name: 'b', index: 0 };
    expect(D(a, b)).toBeGreaterThan(0);
  });

  test('should return negative when priorities are equal and a.name < b.name', () => {
    const a = { priority: 1, name: 'a', index: 0 };
    const b = { priority: 1, name: 'b', index: 0 };
    expect(D(a, b)).toBe(-1);
  });

  test('should return positive when priorities are equal and a.name > b.name', () => {
    const a = { priority: 1, name: 'b', index: 0 };
    const b = { priority: 1, name: 'a', index: 0 };
    expect(D(a, b)).toBe(1);
  });

  test('should return difference of indices when priorities and names are equal', () => {
    const a = { priority: 1, name: 'a', index: 0 };
    const b = { priority: 1, name: 'a', index: 1 };
    expect(D(a, b)).toBe(-1);
  });

  test('should return 0 when all properties are equal', () => {
    const a = { priority: 1, name: 'a', index: 0 };
    const b = { priority: 1, name: 'a', index: 0 };
    expect(D(a, b)).toBe(0);
  });

  test('should handle undefined properties', () => {
    const a = { priority: 1 };
    const b = { priority: 1, name: 'b', index: 0 };
    expect(D(a, b)).toBeLessThan(0);
  });

  test('should handle null values', () => {
    const a = null;
    const b = { priority: 1, name: 'b', index: 0 };
    expect(() => D(a, b)).toThrow();
  });

  test('should handle empty objects', () => {
    const a = {};
    const b = {};
    expect(D(a, b)).toBe(NaN);
  });

  test('should handle non-numeric priority values', () => {
    const a = { priority: 'high', name: 'a', index: 0 };
    const b = { priority: 'low', name: 'b', index: 0 };
    expect(D(a, b)).toBe(NaN);
  });
});
