// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Yb_cb7c1bdd21
ROOST_METHOD_SIG_HASH=Yb_d7bfa6e8e2


*/

// ********RoostGPT********
const { Yb } = require('../src/public/javascripts/library/angular.min.js');

describe('Yb function', () => {
  let mockE;

  beforeEach(() => {
    mockE = jest.fn((constructor, prototype) => {
      return Object.assign(Object.create(prototype), constructor);
    });
    global.E = mockE;
  });

  test('should create a new object with the given prototype and properties', () => {
    const prototype = { method1: jest.fn() };
    const properties = { prop1: 'value1' };

    const result = Yb(prototype, properties);

    expect(mockE).toHaveBeenCalledTimes(2);
    expect(mockE.mock.calls[0][0]).toEqual(function(){});
    expect(mockE.mock.calls[0][1]).toEqual({ prototype });
    expect(mockE.mock.calls[1][1]).toEqual(properties);
    expect(result).toHaveProperty('method1');
    expect(result).toHaveProperty('prop1', 'value1');
  });

  test('should work with empty prototype and properties', () => {
    const result = Yb({}, {});

    expect(mockE).toHaveBeenCalledTimes(2);
    expect(result).toEqual({});
  });

  test('should override prototype properties with given properties', () => {
    const prototype = { prop1: 'protoValue', method1: jest.fn() };
    const properties = { prop1: 'newValue', prop2: 'value2' };

    const result = Yb(prototype, properties);

    expect(result).toHaveProperty('prop1', 'newValue');
    expect(result).toHaveProperty('prop2', 'value2');
    expect(result).toHaveProperty('method1');
  });

  test('should handle null or undefined inputs', () => {
    expect(() => Yb(null, {})).not.toThrow();
    expect(() => Yb({}, null)).not.toThrow();
    expect(() => Yb(undefined, {})).not.toThrow();
    expect(() => Yb({}, undefined)).not.toThrow();
  });

  test('should preserve the prototype chain', () => {
    const grandParent = { grandParentMethod: jest.fn() };
    const parent = Object.create(grandParent);
    parent.parentMethod = jest.fn();
    const properties = { childMethod: jest.fn() };

    const result = Yb(parent, properties);

    expect(result).toHaveProperty('childMethod');
    expect(result).toHaveProperty('parentMethod');
    expect(result).toHaveProperty('grandParentMethod');
    expect(Object.getPrototypeOf(Object.getPrototypeOf(result))).toBe(grandParent);
  });

  test('should handle complex nested objects', () => {
    const prototype = {
      nested: {
        method: jest.fn(),
        value: 'protoValue'
      }
    };
    const properties = {
      nested: {
        value: 'newValue',
        additionalProp: 'additional'
      }
    };

    const result = Yb(prototype, properties);

    expect(result.nested).toHaveProperty('method');
    expect(result.nested).toHaveProperty('value', 'newValue');
    expect(result.nested).toHaveProperty('additionalProp', 'additional');
  });
});
