// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=E_418d8a67f4
ROOST_METHOD_SIG_HASH=E_cb7bdc7752


*/

// ********RoostGPT********
const E = require('../../../src/public/javascripts/library/angular.min.js').E;

describe('E function', () => {
  test('should merge properties from multiple objects', () => {
    const obj1 = { a: 1, b: 2 };
    const obj2 = { c: 3 };
    const obj3 = { d: 4 };

    const result = E(obj1, obj2, obj3);

    expect(result).toEqual({ a: 1, b: 2, c: 3, d: 4 });
  });

  test('should overwrite existing properties', () => {
    const obj1 = { a: 1, b: 2 };
    const obj2 = { b: 3, c: 4 };

    const result = E(obj1, obj2);

    expect(result).toEqual({ a: 1, b: 3, c: 4 });
  });

  test('should preserve the $hashKey of the first object', () => {
    const obj1 = { $hashKey: 'abc123', a: 1 };
    const obj2 = { b: 2 };

    const result = E(obj1, obj2);

    expect(result.$hashKey).toBe('abc123');
  });

  test('should handle empty objects', () => {
    const obj1 = { a: 1 };
    const obj2 = {};

    const result = E(obj1, obj2);

    expect(result).toEqual({ a: 1 });
  });

  test('should handle null or undefined arguments', () => {
    const obj1 = { a: 1 };

    const result = E(obj1, null, undefined);

    expect(result).toEqual({ a: 1 });
  });

  test('should return the first object if no other arguments are provided', () => {
    const obj1 = { a: 1 };

    const result = E(obj1);

    expect(result).toBe(obj1);
  });

  test('should handle non-object arguments', () => {
    const obj1 = { a: 1 };
    const obj2 = { b: 2 };

    const result = E(obj1, obj2, 'string', 123, true);

    expect(result).toEqual({ a: 1, b: 2 });
  });

  test('should merge nested objects', () => {
    const obj1 = { a: { b: 1 } };
    const obj2 = { a: { c: 2 } };

    const result = E(obj1, obj2);

    expect(result).toEqual({ a: { c: 2 } });
  });

  test('should handle array arguments', () => {
    const obj1 = { a: 1 };
    const arr1 = [2, 3, 4];

    const result = E(obj1, arr1);

    expect(result).toEqual({ a: 1, '0': 2, '1': 3, '2': 4 });
  });

  test('should preserve the prototype chain of the first object', () => {
    function CustomObject() {}
    CustomObject.prototype.method = function() {};

    const obj1 = new CustomObject();
    obj1.a = 1;
    const obj2 = { b: 2 };

    const result = E(obj1, obj2);

    expect(result).toBeInstanceOf(CustomObject);
    expect(result.method).toBeDefined();
  });
});
