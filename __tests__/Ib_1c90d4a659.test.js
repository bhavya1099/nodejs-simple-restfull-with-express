// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=Ib_03e8b26aeb
ROOST_METHOD_SIG_HASH=Ib_1c90d4a659


*/

// ********RoostGPT********
const { Ib } = require('../src/public/javascripts/library/angular.min.js');

describe('Ib function', () => {
  let mockElement;

  beforeEach(() => {
    mockElement = {
      cloneNode: jest.fn().mockReturnValue({ id: 'clonedElement' })
    };
  });

  test('should call cloneNode with true', () => {
    Ib(mockElement);
    expect(mockElement.cloneNode).toHaveBeenCalledWith(true);
  });

  test('should return the result of cloneNode', () => {
    const result = Ib(mockElement);
    expect(result).toEqual({ id: 'clonedElement' });
  });

  test('should handle null input', () => {
    expect(() => Ib(null)).toThrow();
  });

  test('should handle undefined input', () => {
    expect(() => Ib(undefined)).toThrow();
  });

  test('should handle input without cloneNode method', () => {
    const invalidElement = {};
    expect(() => Ib(invalidElement)).toThrow();
  });

  test('should preserve properties of original element', () => {
    const originalElement = {
      id: 'original',
      className: 'test-class',
      cloneNode: function(deep) {
        return { ...this, id: 'cloned' };
      }
    };
    const clonedElement = Ib(originalElement);
    expect(clonedElement.id).toBe('cloned');
    expect(clonedElement.className).toBe('test-class');
  });

  test('should create a deep clone', () => {
    const nestedElement = {
      child: { id: 'child' },
      cloneNode: function(deep) {
        return JSON.parse(JSON.stringify(this));
      }
    };
    const clonedElement = Ib(nestedElement);
    expect(clonedElement.child.id).toBe('child');
    expect(clonedElement.child).not.toBe(nestedElement.child);
  });
});
