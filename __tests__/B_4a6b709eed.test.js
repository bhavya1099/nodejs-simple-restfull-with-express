// ********RoostGPT********
/*
Test generated by RoostGPT for test advancedReportTest using AI Type  and AI Model 

ROOST_METHOD_HASH=B_277eb70238
ROOST_METHOD_SIG_HASH=B_4a6b709eed


*/

// ********RoostGPT********
const { B } = require('../src/public/javascripts/library/angular.min.js');

describe('B function', () => {
  let mockA, mockB, mockElement;

  beforeEach(() => {
    mockA = {
      $attr: {},
      $set: jest.fn(),
      class: '',
      style: ''
    };
    mockB = {
      $attr: {}
    };
    mockElement = {
      attr: jest.fn()
    };
    mockA.$element = mockElement;
  });

  test('should merge attributes from b to a', () => {
    mockB.testAttr = 'testValue';
    mockB.$attr.testAttr = 'test-attr';

    B(mockA, mockB);

    expect(mockA.testAttr).toBe('testValue');
    expect(mockA.$attr.testAttr).toBe('test-attr');
  });

  test('should handle class attribute', () => {
    mockB.class = 'newClass';
    
    B(mockA, mockB);

    expect(mockA.class).toBe('newClass');
    expect(mockElement.attr).toHaveBeenCalledWith('class', 'newClass');
  });

  test('should handle style attribute', () => {
    mockA.style = 'color: red;';
    mockB.style = 'font-size: 12px;';
    
    B(mockA, mockB);

    expect(mockA.style).toBe('color: red;font-size: 12px;');
    expect(mockElement.attr).toHaveBeenCalledWith('style', 'color: red;;font-size: 12px;');
  });

  test('should not overwrite existing attributes in a', () => {
    mockA.existingAttr = 'existingValue';
    mockB.existingAttr = 'newValue';

    B(mockA, mockB);

    expect(mockA.existingAttr).toBe('existingValue');
  });

  test('should ignore attributes starting with $', () => {
    mockB.$ignore = 'ignoreMe';

    B(mockA, mockB);

    expect(mockA.$ignore).toBeUndefined();
  });

  test('should concatenate values for existing attributes', () => {
    mockA.testAttr = 'value1';
    mockB.testAttr = 'value2';
    mockB.$attr.testAttr = 'test-attr';

    B(mockA, mockB);

    expect(mockA.testAttr).toBe('value1 value2');
  });

  test('should handle empty a and b objects', () => {
    const emptyA = { $attr: {}, $element: { attr: jest.fn() } };
    const emptyB = { $attr: {} };

    B(emptyA, emptyB);

    expect(emptyA).toEqual({ $attr: {}, $element: { attr: expect.any(Function) } });
  });

  test('should handle null or undefined values', () => {
    mockB.nullAttr = null;
    mockB.undefinedAttr = undefined;

    B(mockA, mockB);

    expect(mockA.nullAttr).toBeNull();
    expect(mockA.undefinedAttr).toBeUndefined();
  });
});
